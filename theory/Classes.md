# Classes

## Стиль оформления структур

- Имя структуры записываем с заглавной буквы. Если состоит из нескольких слов, то каждое слово пишется 
с заглавной буквы. Примеры: Car, GameUnit, Point, TreeNode.
- Имена полей пишем строчными буквами, подобно обычным переменным. Если имя поля состоит из нескольких 
слов, между ними ставится знак подчёркивания: birth_year, address, is_sorted. 
- Фигурная скобка открывается после имени структуры в той же строке. 
- Имена полей записываются с отступом в четыре пробела. 
- Поля, даже если они имеют один и тот же тип, записываются на отдельных строках. В некоторых случаях ради
экономии места можно объявить несколько однотипных полей в одной строке, если это не ухудшает читаемость.

```c++
// Фигурная скобка открывается на строке с именем структуры.
struct Person {
    // Поля записываются одно под другим с отступом в 4 пробела.
    std::string name;
    std::string surname;
    int age;
    Gender gender;
};
// Закрывающая скобка находится под словом struct.

struct Point {
    // Запись координат точки в одну строку не ухудшает читаемость кода.
    double x, y;
};
```

## назначенная инициализация
**назначенная инициализация** (англ. designated initialization) - явное указание имени поля и его значения.
```c++
int main() {
    Robot robot1 { .energy = 30.0, .speed = 25.7 };

    // Пропускать поля можно.
    // Поле energy получит нулевое значение.
    Robot robot2 { .speed = 10.4 };
}
```

Если перечислить поля в порядке, отличном от указанного в структуре, будет ошибка.

# Init
для полей структуры можно задать значение по умолчанию в описании:
```c++
// Теперь по умолчанию RGBAColor инициализирована чёрным непрозрачным цветом.
struct RGBAColor {
    float red = 0;   // Инициализируем числом.
    float green{0}; // Можно и так проинициализировать нулём.
    float blue{};    // Так по умолчанию поле инициализировано нулём.
    float alpha = 1; // Цвет по умолчанию полностью непрозрачный.
};

int main() {
    RGBAColor red = {1, 0, 0};         // Красный.
    RGBAColor white = {1, 1, 1};       // Белый.
    RGBAColor black = {0, 0, 0};       // Чёрный.
    RGBAColor grey = {0.5, 0.5, 0.5};  // Серый.
    RGBAColor yellow = {1, 1, 0};      // Жёлтый.

    // Полупрозрачный жёлтый цвет.
    RGBAColor semi_transparent_yellow = {1, 1, 0, 0.5}; 

    // Теперь такого понятия, как «неинициализированный цвет», нет.
    // По умолчанию цвет будет непрозрачным чёрным.
    RGBAColor initialized_color;
}
```

## По константной ссылке или по значению

Если функция будет принимать параметр по ссылке, это избавит от копирования. Однако параметр-ссылка сообщает,
что функция может модифицировать переданное значение. Так как переменная `p1` константная, то нельзя изменять
её значение. А так как функция принимает по ссылке, то может изменить значение своего аргумента.
Поэтому компилятор выдаст ошибку.

Способы передачи значения в функцию
- По ссылке. Используется, когда от функции ожидается, что она изменит значение своего аргумента.
- По константной ссылке. Используется, когда функция не изменяет структуру, а сама структура тяжела для передачи по значению.
- По значению. Во всех остальных случаях.

![img.png](../../img.png)

## Invariant
Со структурами, подобными `Date`, тесно связано понятие «инвариант». Это условие, которое должно соблюдаться при
любых манипуляциях над объектом, чтобы состояние объекта было непротиворечивым. Для структуры Date инвариант можно
описать в виде набора следующий условий:
- Год должен принимать значения от 1 до 9999. Для решения большинства практических задач этого вполне достаточно.
- Месяц должен быть целым числом от 1 до 12.
- День должен быть целым числом от 1 до количества дней в этом месяце (с учётом високосности текущего года).

Независимо от манипуляций, которые проводятся над структурой `Date`, в конце должны быть соблюдены описанные 
условия. Тогда структура будет переходить от одного валидного состояния к другому.

## Struct and Class

В C++ методы могут быть не только у классов, но и у структур.

```c++
struct Vector {
    double x = 0;
    double y = 0;
};

struct Point {
    // Сдвигает точку вдоль вектора v.
    void OffsetByVector(Vector v) {
        x += v.x;
        y += v.y;
    }

    double x = 0;
    double y = 0;
};

int main() {
    Point p{10, 15};
    Vector v{7, -3.5};

    // Сдвигаем точку вызовом метода OffsetByVector.
    p.OffsetByVector(v);
}
```

## Сравнение методов и свободных функций для смещения точки вектором

### Методы (p.OffsetByVector(v);)

#### Плюсы:
*   **Краткость записи:** `p.OffsetByVector(v);` короче, чем `OffsetPointByVector(p, v);`.
*   **Очевидность применения:** Операция очевидно применяется к точке, так как вызывается метод структуры `Point`.
*   **Легкость обнаружения:** Метод легко обнаружить, просмотрев структуру `Point`. Большинство IDE подскажут
доступные методы после набора `p.`.

#### Минусы:
*   **Зависимость от `Vector`:** Метод `OffsetByVector` добавляет в структуру `Point` зависимость от структуры 
`Vector`. `Point` не может быть использована без `Vector`. Изменения в `Vector` могут повлиять на `Point`. 
Если `Vector` является частью крупной библиотеки, это добавляет зависимость от всей библиотеки.
*   **Необходимость контроля над кодом:** Чтобы добавить или изменить метод, код структуры или класса должен быть
под вашим контролом. При использовании внешней библиотеки, обновления могут потребовать повторного внесения 
изменений. Лицензия библиотеки также может запрещать модификации или налагать обязательства.

### Свободные функции (OffsetPointByVector(p, v);)

#### Плюсы:
*   **Отсутствие зависимости:** `Point` не зависит от `Vector`. Использование `Point` не обязывает использовать
`Vector`. Изменения в `Vector` не влияют на `Point`.
*   **Независимость от контроля кода:** Для написания свободной функции не требуется контролировать код структур 
`Point` и `Vector`. Это позволяет использовать их из внешних библиотек, не беспокоясь об обновлениях.
Многие лицензии менее требовательны, если библиотека используется без изменения ее кода.

#### Минусы:
*   **Неочевидность существования функции:** Из структуры `Point` не очевидно, что существует функция для смещения
точки вектором, особенно если она объявлена в другом файле. Это может привести к дублированию кода или ручному перемещению.
*   **Ограничения публичного интерфейса:** Если публичный интерфейс класса не позволяет решить задачу,
все равно придется добавлять метод.

## `static` methods

У статических методов есть особенности, которые отличают их от обычных методов.
- С ними не связан никакой экземпляр класса, поэтому статические методы не получают указатель this.
- Так как текущего объекта нет, то из статического метода нельзя обратиться к данным объекта.
- Также из статического метода нельзя вызывать методы объекта — за исключением статических.
- Если снаружи в статический метод передали экземпляр класса, то статический метод может обращаться
к его полям и методам, в том числе приватным.

**Статическое поле** — общее для всех экземпляров класса. Оно создаётся при запуске программы и уничтожается
при её завершении. Для доступа к статическим полям не нужен объект, поэтому их можно использовать и из
статических методов. Чтобы объявить статическое поле, надо перед его типом написать ключевое слово `static`.

После объявления статического поля его нужно определить за пределами класса. Обычно для этого используют 
.cpp-файл, в котором размещаются методы класса. Как и при объявлении методов класса за его пределами, нужно
указывать полное имя статического поля в виде `ИмяКласса::имя_поля_`.

```c++
#include <vector>

struct GearSpeedRange {
    Gear gear;
    int min_speed;
    int max_speed;
};

class Car {
    ...
    static bool IsSpeedValidForGear(int speed, Gear gear);
private:
    bool engine_is_on_ = false;
    int speed_ = 0;
    Gear gear_ = Gear::NEUTRAL;

    // Объявляем таблицу диапазонов скоростей статической и константной,
    // чтобы она была одна всю программу и не изменялась.
    static const std::vector<GearSpeedRange> speed_ranges_;
};
```

```c++
// Это файл car.cpp. Он содержит реализацию класса Car.

#include "car.h"

// Так объявляется статическая переменная за пределами класса.
// Наполняем вектор значениями.
const std::vector<GearSpeedRange> Car::speed_ranges_ = {
    { Gear::NEUTRAL, 0, 150 },
    { Gear::FIRST, 0, 30 },
    { Gear::SECOND, 20, 50 },
    { Gear::THIRD, 30, 70 },
    { Gear::FOURTH, 40, 100 },
    { Gear::FIFTH, 60, 150 },
    { Gear::REVERSE, 0, 30 },
};

bool Car::IsSpeedValidForGear(int speed, Gear gear) {
    for (auto& range : speed_ranges_) {
        if (range.gear == gear) {
            return range.min_speed <= speed && speed <= range.max_speed;
        }
    }
    return false;
}
```

*Начиная с C++17, статические переменные класса можно определить в .h-файле,
прямо внутри класса или структуры. Для этого поле помечают ключевым словом inline.*

## Const

Константная ссылка запрещает изменения, а значит, запрещает вызовы обычных методов. Чтобы сообщить компилятору,
что метод не будет модифицировать объект - нужно сделать метод константным. Для этого между списком параметров
и телом метода нужно написать спецификатор `const`.
```c++
class Cat {
    ...
    // Cпецификатор const означает, что метод константный.
    //                      ↓
    std::string GetName() const {
        return name_;
    }
    ...
};
```

Компилятор не разрешает внутри константного метода менять состояние объекта. Компилятор выдаст ошибку, если:
- попытаться присвоить полю класса новое значение;
- попытаться вызвать неконстантный метод текущего объекта;
- попытаться вызвать у поля класса неконстантный метод (если поле — класс или структура);
- попытаться передать поле класса в функцию, которая принимает аргумент по неконстантной ссылке;
- делаете всё вышеперечисленное через this.

```c++
class Cat {
    ...
    std::string GetName() const {
        name_ = "Unknown name"s; // Ошибка: нельзя изменить значение поля класса 
                                 // внутри константного метода.

        name_.push_back('!');    // Ошибка: нельзя вызвать неконстантный метод 
                                 // у поля класса.

        NonConstMethod();        // Ошибка: нельзя вызвать неконстантный метод 
                                 // у текущего объекта.

        this->NonConstMethod();  // Ошибка: всё вышеперечисленное нельзя делать
                                 // через this.
        return name_;
    }
    ...
    void NonConstMethod() {
    }
};
```

Когда тело метода описано вне класса, спецификатор `const` должен быть как в объявлении класса 
(в этом случае `const` стоит между списком аргументов и точкой с запятой), так и в его определении.

Статические методы не имеют связанного экземпляра класса, поэтому не могут быть константными. 
Компилятор выдаст ошибку при попытке скомпилировать статический метод.

константные и статические методы различаются по степени доступа к текущему объекту (`this`). 
Обычные методы могут читать и записывать данные объекта, в то время как статические методы никак не 
взаимодействуют с текущим объектом (но могут использовать другие объекты этого класса):


| Method   | Change | Read |
|----------|--------|------|
| Norm     |    Y   | Y    |
| `const`  |    N   | Y    |
| `static` |    N   | N    |

## Список инициализации конструктора

если тип поля не имеет конструктора по умолчанию

```c++
class Alice {
public:
    Alice(int age) {
        std::cout << "Alice("s << age << ") is created"s << std::endl;
    }
};

class Carol {
public:
    Carol(int alice_age) { 
        std::cout << "Carol is created"s << std::endl; 
        alice_ = Alice(alice_age);
    }

private:
    Alice alice_; // Ошибка! Не можем создать объект без
                  // параметров конструктора.
};
```

способ с присваиванием - не работает. Чтобы решить проблему, можно использовать специальный механизм — 
список **инициализации конструктора**. Этот механизм позволяет указать параметры инициализации для
выбранных полей класса

```c++
class Carol {
public:
    Carol(int alice_age)
        : alice_{alice_age} // Вызывается конструктор Alice::Alice(int age).
        , name_("Luis"s)   // Инициализируем поле строкового типа. Можно использовать круглые 
        // скобки, однако фигурные скобки являются более универсальными.
    {
        std::cout << "Carol is created"s << std::endl; 
    }

    std::string GetName() const {
        return name_;
    }
private:
    Alice alice_;
    Bob bob_;
    std::string name_;
};

int main() {
    Carol carol{17};
    std::cout << "Name: " << carol.GetName() << std::endl;
}
```

если тип поля класса имеет конструктор по умолчанию, для инициализации поля следует использовать не
тело конструктора, а список инициализации. Так будет сгенерирован более компактный и эффективный 
код — вместо инициализации поля и последующего присваивания нового значения выполняется только инициализация

Список инициализации — это также единственный способ инициализации полей, которые являются константами. 

В C++ можно объявлять ссылки на существующие переменные. После этого с объектом можно работать не только
напрямую, но и с использованием ссылки. При объявлении ссылка должна быть обязательно проинициализирована.

```c++
std::string name;
// ref_name — ссылка на переменную name. Амперсанд & означает, что это ссылка.
std::string& ref_name = name;

// Когда изменяется ссылка, изменяется объект.
ref_name = "John";
assert(name == "John");

// Когда изменяем объект, изменения становятся видны и при доступе к нему по ссылке.
name += " Smith";
assert(ref_name == "John Smith");
```